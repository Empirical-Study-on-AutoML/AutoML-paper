# -*- coding: utf-8 -*-
"""Jan 6th_getting_the_function_calls.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cTTky9IKuQWwsq90ROJBUdeP4HyBqMdc

#getting the imports
"""

# from google.colab import drive
# drive.mount('/content/drive')

"""
In the next cell:
*  we get the list of imports using ast.Import and ast.ImportFrom.
*  we save the list of imports into a csv file.


"""

import csv
import py_compile
import ast
import pandas as pd

path_output = "../data/14-01-2022c/imports/"
path_source_code = '../data/downloaded_code'
path_function = '../data/14-01-2022c/functions/'
path_config = '../data/'
path_to_error_csv = "../data/14-01-2022c/errors/"
path_to_the_unsuccessful_converts_to_py = "../data/14-01-2022c/"


df_ = pd.read_csv(path_config + 'config-files.csv')
merged_configs = df_.merged_configs.values.tolist()
list_final_automl = []
for config in merged_configs:
    for splited in str(config).split(','):
        splited_ = str(splited).replace('"', '')
        splited_ = str(splited_).replace("'", '')
        splited_ = str(splited_).replace(" ", '')
        splited_ = str(splited_).replace("from", '')
        splited_ = str(splited_).replace("import", '')
        splited_ = str(splited_).replace("+", '')
        if not splited_ in list_final_automl:
            list_final_automl.append(splited_)
def getting_the_imports(file_sha, file_path, file_name, code_example):
    automl_tools_name = list_final_automl

    list_of_automl_related_imports = []
    try:
        tree = ast.parse(code_example)
        tree_body = tree.body
    except Exception as e:
        print('Errors overal during the parsing: ', e)
        return list_of_automl_related_imports
    list_of_all_imports = []
    asin_name_dict = {}
    count = 0
    index = 0
    for item in tree_body:
        index += 1

        if isinstance(item, ast.Import):
            for i in item.names:
                all_imports = dict()
                all_imports['name'] = i.name
                all_imports['asname'] = i.asname
                all_imports['module'] = None
                list_of_all_imports.append(all_imports)
                list_asname = []
                for key, val in asin_name_dict.items():
                    for val2 in val:
                        list_asname.append(val2)
                if "." in i.name:
                    splited_list = i.name.split(".")
                    for splitted_name in splited_list:
                        if splitted_name in automl_tools_name or splitted_name in list_asname:
                            new_import = dict()
                            new_import['file_name'] = file_name
                            new_import['file_sha'] = file_sha
                            new_import['file_path'] = file_path
                            new_import['total_name'] = i.name
                            new_import['name'] = i.name
                            new_import['module'] = None
                            new_import['asname'] = i.asname
                            new_import['splitted_module'] = splitted_name
                            new_import['functions_attached_to_name'] = splited_list[
                                                                       splited_list.index(splitted_name) + 1:]
                            if i.asname != None:
                                asin_name_dict[splitted_name] = [i.asname]
                            list_of_automl_related_imports.append(new_import)
                elif i.name in automl_tools_name:
                    new_import = dict()
                    new_import['file_name'] = file_name
                    new_import['file_sha'] = file_sha
                    new_import['file_path'] = file_path
                    new_import['total_name'] = i.name
                    new_import['name'] = i.name
                    new_import['module'] = None
                    new_import['asname'] = i.asname
                    new_import['splitted_module'] = None
                    new_import['functions_attached_to_name'] = None

                    list_of_automl_related_imports.append(new_import)
                    if i.asname != None:
                        asin_name_dict[i.name] = [i.asname]

        #########################################################################################################
        # study import_from only

        if isinstance(item, ast.ImportFrom):
            for n in item.names:
                all_imports = dict()
                all_imports['name'] = n.name
                all_imports['asname'] = n.asname
                all_imports['module'] = item.module
                list_of_all_imports.append(all_imports)
            if "." in str(item.module):
                list_asname = []
                for key, val in asin_name_dict.items():
                    for val2 in val:
                        list_asname.append(val2)
                counter = 0
                for splitted_module in item.module.split("."):
                    if splitted_module in automl_tools_name or splitted_module in list_asname:
                        for i in item.names:
                            new_import = dict()
                            new_import['file_name'] = file_name
                            new_import['file_sha'] = file_sha
                            new_import['file_path'] = file_path
                            new_import['total_name'] = item.module
                            new_import['name'] = i.name
                            new_import['module'] = item.module
                            new_import['asname'] = i.asname
                            new_import['splitted_module'] = splitted_module
                            new_import['functions_attached_to_name'] = item.module.split(".")[counter + 1:]
                            list_of_automl_related_imports.append(new_import)
                            if i.asname != None:
                                asin_name_dict[i.name] = [i.asname]
                        break
                    counter += 1

            elif item.module in automl_tools_name:
                for i in item.names:
                    new_import = dict()
                    new_import['file_name'] = file_name
                    new_import['file_sha'] = file_sha
                    new_import['file_path'] = file_path
                    new_import['total_name'] = item.module
                    new_import['name'] = i.name
                    new_import['module'] = item.module
                    new_import['asname'] = i.asname
                    new_import['splitted_module'] = None
                    new_import['functions_attached_to_name'] = None
                    list_of_automl_related_imports.append(new_import)
                    if i.asname != None:
                        asin_name_dict[i.name] = [i.asname]

    if len(list_of_automl_related_imports) > 0:
        keys = list_of_automl_related_imports[0].keys()

        with open(path_output + 'list_of_imports_{}.csv'.format(file_sha), 'w', newline='') as output_file:
            dict_writer = csv.DictWriter(output_file, keys)
            dict_writer.writeheader()
            dict_writer.writerows(list_of_automl_related_imports)

        return list_of_automl_related_imports


"""#transferring data from import part to function call part

In the next cell:

*   we are are creating a list that contains the imports that we extracted in the second cell.
"""


def transferring_data_from_import_function_to_function_call_function(list_of_automl_related_imports):
    list_of_final_imports_or_asnames = []
    List_of_both_names_asname = []
    if list_of_automl_related_imports != None:
        for import_obj in list_of_automl_related_imports:
            if import_obj['asname'] != None:
                list_of_final_imports_or_asnames.append(import_obj['asname'])
            else:
                list_of_final_imports_or_asnames.append(import_obj['name'])
            List_of_both_names_asname.append([import_obj['name'], import_obj['asname'], import_obj['total_name'],
                                              import_obj['total_name'].split('.')[0]])
    return List_of_both_names_asname


"""#getting the function call part

In the next cell:


*   We are getting th function call in the next cell
*   We are getting the:
    *   function calls that are directly mentioned in the code
    *   function calls in the right side of the assignments
    *   function calls that are mentioned in the following statements: if,      while, try, for, with, list, tuple, unaryOp.
    *   function calls in the "return" statement.

*   If an automl tool is the parent of a class, we are getting the function call of the objects of that class too.
"""


def _check_attribute(list_of_attr):
    complete_val = list_of_attr
    if isinstance(list_of_attr, list):
        complete_val = '.'.join(list_of_attr)
    if len(list_of_attr) > 1:
        val = list_of_attr[1:]
        if isinstance(list_of_attr[1:], list):
            val = '.'.join(list_of_attr[1:])
    else:
        val = list_of_attr[0]
        if isinstance(list_of_attr[0], list):
            val = '.'.join(list_of_attr[0])
    return val, complete_val


class Analyze_Function_call:
    def __init__(self, list_of_automl_related_imports, List_of_both_names_asname, file_name, file_path, file_sha,
                 code_example, path_to_error_csv, python_version):
        self.list_of_automl_related_imports = list_of_automl_related_imports
        self.List_of_both_names_asname = List_of_both_names_asname
        self.total_list_of_function_calls = []
        self.line_number = 0
        self.file_name = file_name
        self.file_path = file_path
        self.file_sha = file_sha
        self.code_example = code_example
        self.path_for_function_call = path_function  
        self.line_contain_assignment = False
        self.current_assignment_name = ''
        self.list_of_created_obj = []
        self.path_to_error_csv = path_to_error_csv
        self.flag_for_having_automl_parent = False
        self.python_version = python_version

        mode2 = 'w'
        if not os.path.exists(self.path_to_error_csv + 'error_file.csv'):
            mode2 = 'w'
            self.error_data_file = open(self.path_to_error_csv + 'error_file.csv', mode=mode2, newline='',
                                        encoding='utf-8')
        else:
            mode2 = 'a+'
            self.error_data_file = open(self.path_to_error_csv + 'error_file.csv', mode=mode2, newline='',
                                        encoding='utf-8')
        self.error_writer = csv.writer(self.error_data_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
        if mode2 == 'w':
            self.error_writer.writerow(['file_name', 'file_path', 'file_sha', 'error', 'item dump'])

        mode = 'w'
        if not os.path.exists(self.path_for_function_call + 'combined_function_calls.csv'):
            mode = 'w'
            self.data_file = open(self.path_for_function_call + 'combined_function_calls.csv', mode=mode, newline='',
                                  encoding='utf-8')
        else:
            mode = 'a+'
            self.data_file = open(self.path_for_function_call + 'combined_function_calls.csv', mode=mode, newline='',
                                  encoding='utf-8')
        self.data_writer = csv.writer(self.data_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
        if mode == 'w':
            self.data_writer.writerow(
                ['fileShaa', 'fileName', 'filePath', 'name_or_asname', 'totl_name', 'name of the automl tool', 'asName',
                 'name', 'created_obj_name', 'function_call', 'complete_functions', 'line_number',
                 "complete_function_call_plus_tool_name_and_history_of_calls", "final_function_call", 'python_version'])

    def write_on_csv(self, error, dump):
        self.error_writer.writerow([self.file_name, self.file_path, self.file_sha, error, dump])


        if isinstance(node.value, ast.Name):
            list_of_attr.append(node.value.id)
        elif isinstance(node.value, ast.Attribute):
            self.recurssion_func_to_get_list_of_called_functionalities(node.value, list_of_attr)
        elif isinstance(node.value, ast.Call):
            self.nested_function_calls(node.value, list_of_attr)
        list_of_attr.append(node.attr)

    def nested_function_calls(self, item, list_of_attr):
        if isinstance(item.func, ast.Name):
            list_of_attr.append(item.func.id)
        elif isinstance(item.func, ast.Attribute):
            if isinstance(item.func.value, ast.Name):
                list_of_attr.append(item.func.value.id)
            elif isinstance(item.func.value, ast.Attribute):
                self.recurssion_func_to_get_list_of_called_functionalities(item.func.value, list_of_attr)
            list_of_attr.append(item.func.attr)

    def recurssion_func_to_get_list_of_called_functionalities_from_annotation(self, node, list_of_attr=[]):
        if isinstance(node, ast.Name):
            list_of_attr.append(node.id)
        elif isinstance(node, ast.Attribute):
            if isinstance(node.value, ast.Name):
                list_of_attr.append(node.value.id)
            elif isinstance(node.value, ast.Attribute):
                self.recurssion_func_to_get_list_of_called_functionalities_from_annotation(node.value, list_of_attr)
            list_of_attr.append(node.attr)

    def getting_the_function_calls(self, item):
        list_of_attr = []
        if isinstance(item.func, ast.Name):
            list_of_attr.append(item.func.id)
        elif isinstance(item.func, ast.Attribute):
            if isinstance(item.func.value, ast.Name):
                list_of_attr.append(item.func.value.id)
            elif isinstance(item.func.value, ast.Attribute):
                self.recurssion_func_to_get_list_of_called_functionalities(item.func.value, list_of_attr)
            elif isinstance(item.func.value, ast.Call):
                self.nested_function_calls(item.func.value, list_of_attr)
            list_of_attr.append(item.func.attr)
        if len(list_of_attr) > 0 and len(list_of_attr) < 2:
            main_library = list_of_attr[0]
            main_library2 = False
            main_library3 = False
            if len(list_of_attr) >= 2 and len(list_of_attr) < 3:
                main_library2 = list_of_attr[0] + "." + list_of_attr[1]
                main_library = False
                main_library3 = False
            if len(list_of_attr) >= 3 and len(list_of_attr) < 4:
                main_library3 = list_of_attr[0] + "." + list_of_attr[1] + "." + list_of_attr[2]
                main_library = False
                main_library2 = False
            lineno = item.func.__dict__['lineno']
            flag = 0
            for r in self.list_of_created_obj:
                if main_library == r[0] or (main_library == "super" and self.flag_for_having_automl_parent == True):
                    flag += 1
                    row_data = {}
                    row_data['fileShaa'] = self.file_sha
                    row_data['fileName'] = self.file_name
                    row_data['filePath'] = self.file_path
                    row_data['name_or_asname'] = main_library
                    row_data['total_name'] = r[3]
                    row_data['name_of_the_tool'] = r[4]
                    row_data['asName'] = r[2]
                    row_data['name'] = r[1]
                    row_data['created_obj_name'] = r[0]
                    val, complete_function = _check_attribute(list_of_attr)
                    row_data['function_call'] = val
                    row_data['complete_functions'] = complete_function
                    complete_function_call_plus_tool_name_and_history_of_calls = r[5] + "." + val
                    row_data['line_number'] = lineno
                    row_data[
                        'complete_function_call_plus_tool_name_and_history_of_calls'] = complete_function_call_plus_tool_name_and_history_of_calls
                    if r[1] == r[3]:
                        if r[2] != None:
                            final_function_call = (r[1] + "." + r[5] + "." + val)
                        else:
                            if len(r[1].split('.')) > 1:
                                final_function_call = r[4] + "." + r[5] + "." + val
                            else:
                                final_function_call = r[1] + "." + r[5] + "." + val

                    else:
                        if r[2] != None:
                            final_function_call = r[3] + "." + r[1] + "." + r[5] + "." + val
                        else:
                            final_function_call = r[3] + "." + r[1] + "." + r[5] + "." + val
                    row_data['final_function_call'] = final_function_call
                    self.total_list_of_function_calls.append(row_data)
                    self.data_writer.writerow(
                        [self.file_sha, self.file_name, self.file_path, main_library, r[3], r[4], r[2], r[1], r[0], val,
                         "", lineno, complete_function_call_plus_tool_name_and_history_of_calls, final_function_call, self.python_version])
                    break

            if flag == 0:
                for k in self.List_of_both_names_asname:
                    if ((k[1] != None) and (main_library == k[1])) or (
                            main_library == "super" and self.flag_for_having_automl_parent == True):
                        row_data = {}
                        row_data['fileShaa'] = self.file_sha
                        row_data['fileName'] = self.file_name
                        row_data['filePath'] = self.file_path
                        row_data['name_or_asname'] = main_library
                        row_data['total_name'] = k[2]
                        row_data['name_of_the_tool'] = k[3]
                        row_data['asName'] = k[1]
                        row_data['name'] = k[0]
                        row_data['created_obj_name'] = self.current_assignment_name
                        val, complete_function = _check_attribute(list_of_attr)
                        row_data['function_call'] = val
                        row_data['complete_functions'] = complete_function
                        row_data['line_number'] = lineno
                        complete_function_call_plus_tool_name_and_history_of_calls = ""
                        row_data[
                            'complete_function_call_plus_tool_name_and_history_of_calls'] = complete_function_call_plus_tool_name_and_history_of_calls
                        asname_plus_dot = k[1] + "."
                        if k[0] == k[2]:
                            final_function_call = (k[0] + "." + val).replace(asname_plus_dot, "")
                        else:
                            final_function_call = (k[2] + "." + k[0] + "." + val).replace(asname_plus_dot, "")
                        row_data['final_function_call'] = final_function_call
                        self.data_writer.writerow(
                            [self.file_sha, self.file_name, self.file_path, main_library, k[2], k[3], k[1], k[0],
                             self.current_assignment_name, val, complete_function, lineno,
                             complete_function_call_plus_tool_name_and_history_of_calls, final_function_call, self.python_version])
                        self.total_list_of_function_calls.append(row_data)
                        if self.line_contain_assignment:
                            self.list_of_created_obj.append(
                                [self.current_assignment_name, k[0], k[1], k[2], k[3], val, complete_function])
                        break
                    elif ((k[1] == None) and (k[0] != None) and (
                            (main_library == k[0]) or (main_library2 == k[0]) or (main_library3 == k[0]))) or (
                            main_library == "super" and self.flag_for_having_automl_parent == True):
                        row_data = {}
                        row_data['fileShaa'] = self.file_sha
                        row_data['fileName'] = self.file_name
                        row_data['filePath'] = self.file_path
                        row_data['name_or_asname'] = main_library
                        row_data['total_name'] = k[2]
                        row_data['name_of_the_tool'] = k[3]
                        row_data['asName'] = k[1]
                        row_data['name'] = k[0]
                        row_data['created_obj_name'] = self.current_assignment_name
                        val, complete_function = _check_attribute(list_of_attr)
                        row_data['function_call'] = val
                        row_data['complete_functions'] = complete_function
                        row_data['line_number'] = lineno
                        complete_function_call_plus_tool_name_and_history_of_calls = ""
                        row_data[
                            'complete_function_call_plus_tool_name_and_history_of_calls'] = complete_function_call_plus_tool_name_and_history_of_calls

                        if k[0] == k[2]:
                            final_function_call = complete_function
                        else:
                            final_function_call = (k[2] + "." + complete_function)
                        row_data['final_function_call'] = final_function_call
                        self.data_writer.writerow(
                            [self.file_sha, self.file_name, self.file_path, main_library, k[2], k[3], k[1], k[0],
                             self.current_assignment_name, val, complete_function, lineno,
                             complete_function_call_plus_tool_name_and_history_of_calls, final_function_call, self.python_version])
                        self.total_list_of_function_calls.append(row_data)
                        if self.line_contain_assignment:
                            self.list_of_created_obj.append(
                                [self.current_assignment_name, k[0], k[1], k[2], k[3], val, complete_function])
                        break
        if len(item.args) > 0:
            for arg in item.args:
                if isinstance(arg, ast.Call):
                    self.getting_the_function_calls(arg)

    def check_for_expression_and_get_the_details_of_function_calls(self, item):
        if isinstance(item.value, ast.Call):
            self.getting_the_function_calls(item.value)

    def save_to_csv(self):
        if len(self.total_list_of_function_calls) > 0:
            keys = self.total_list_of_function_calls[0].keys()
            with open(self.path_for_function_call + 'function_call_{}.csv'.format(self.file_sha), 'w',
                      newline='') as output_file:
                dict_writer = csv.DictWriter(output_file, keys)
                dict_writer.writeheader()
                dict_writer.writerows(self.total_list_of_function_calls)
        self.error_data_file.close()
        self.data_file.close()

    def check_for_assignment_and_get_the_details_of_function_calls(self, item):
        if isinstance(item.targets[0], ast.Name):
            left_side_of_assignment = item.targets[0].id
            self.line_contain_assignment = True
            self.current_assignment_name = left_side_of_assignment
        if isinstance(item.value, ast.Call):
            self.getting_the_function_calls(item.value)
        else:
            self._check(item.value)

    ### All statement checks starts here
    def _if_statement(self, node):
        if isinstance(node, ast.If):
            ## Checking if the test contain compare
            if isinstance(node.test, ast.Compare):
                self._check(node.test.left)
                for compareto in node.test.comparators:
                    self._check(compareto)
            else:
                self._check(node.test)
            ## Going inside the if body
            for item_body in node.body:
                self._check(item_body)
            ## Else if statement
            for orelse_body in node.orelse:
                self._check(orelse_body)

    def _while_statement(self, node):
        if isinstance(node, ast.While):
            if isinstance(node.test, ast.Compare):
                self._check(node.test.left)
                for compareto in node.test.comparators:
                    self._check(compareto)
            else:
                self._check(node.test)
            for item_body in node.body:
                self._check(item_body)

    def _for_loop(self, node):
        if isinstance(node, ast.AsyncFor) or isinstance(node, ast.For):
            if not isinstance(node.iter, ast.Name):
                self._check(node.iter)
            for item_body in node.body:
                self._check(item_body)

    def _try_statement(self, node):
        if isinstance(node, ast.Try):
            for node_handle in node.handlers:
                for handle_body in node_handle.body:
                    self._check(handle_body)
            for item_body in node.body:
                self._check(item_body)

    def _with_statement(self, node):
        if isinstance(node, (ast.With, ast.AsyncWith)):
            for item in node.items:
                if isinstance(item, ast.withitem):
                    self._check(item.context_expr)
            for node_body in node.body:
                self._check(node_body)

    def _listcom_statement(self, node):
        if isinstance(node, ast.ListComp):
            self._check(node.elt)
            for gen_body in node.generators:
                self._check(gen_body)

    def _assert_statement(self, node):
        if isinstance(node, ast.Assert):
            if isinstance(node.test, ast.Compare):
                self._check(node.test.left)
                for comparator in node.test.comparators:
                    self._check(comparator)

    def _return_statement(self, node):
        if isinstance(node, ast.Return):
            self._check(node.value)

    def _List_or_Tuple_statement(self, node):
        if isinstance(node, (ast.List, ast.Tuple)):
            for list_Tuple_item in node.elts:
                self._check(list_Tuple_item)

    def _unaryOP(self, node):
        if isinstance(node, ast.UnaryOp):
            if isinstance(node.operand, ast.Compare):
                self._check(node.operand.left)
                for comparator in node.operand.comparators:
                    self._check(comparator)

    ## check for all statements here..!
    def _check_statements(self, node):
        if isinstance(node, (ast.If, ast.IfExp)):
            self._if_statement(node)
        elif isinstance(node, ast.While):
            self._while_statement(node)
        elif isinstance(node, ast.Try):
            self._try_statement(node)
        elif isinstance(node, ast.AsyncFor) or isinstance(node, ast.For):
            self._for_loop(node)
        elif isinstance(node, (ast.With, ast.AsyncWith)):
            self._with_statement(node)
        elif isinstance(node, ast.Assert):
            self._assert_statement(node)
        elif isinstance(node, ast.Return):
            self._return_statement(node)
        elif isinstance(node, ast.List) or isinstance(node, ast.Tuple):
            self._List_or_Tuple_statement(node)
        elif isinstance(node, ast.UnaryOp):
            self._unaryOP(node)

    def _check(self, node):
        if isinstance(node, ast.Expr):
            self.check_for_expression_and_get_the_details_of_function_calls(node)
        elif isinstance(node, ast.Assign):
            self.check_for_assignment_and_get_the_details_of_function_calls(node)
        elif isinstance(node, ast.Call):
            self.getting_the_function_calls(node)
        else:
            self._check_statements(node)

    def check_functions(self, node):
        if len(node.args.args) > 0:
            for arg in node.args.args:
                if arg.annotation != None:
                    list_of_attrib = []
                    self.recurssion_func_to_get_list_of_called_functionalities_from_annotation(arg.annotation,
                                                                                               list_of_attrib)

                    if len(list_of_attrib) > 0:
                        if (list_of_attrib[0] in self.List_of_both_names_asname) or (
                                list_of_attrib[0] in self.list_of_created_obj):
                            self.List_of_both_names_asname.append([arg.arg, None, None, None])
        for function_body_item in node.body:
            self.line_contain_assignment = False
            self.current_assignment_name = ''
            self._check(function_body_item)

    # main function that starts getting the function calls
    def main_function(self):
        try:
            tree = ast.parse(self.code_example)
            tree_body = tree.body
        except Exception as e:
            print('Error overral during parsing the tree! ', e)
            self.write_on_csv(e, "Error overral during parsing the tree!")
            return
        for item in tree_body:
            try:
                self.line_number += 1
                self.line_contain_assignment = False
                self.current_assignment_name = ''
                if isinstance(item, ast.ClassDef):
                    for base in item.bases:
                        list_of_attrib = []
                        self.recurssion_func_to_get_list_of_called_functionalities_from_annotation(base, list_of_attrib)
                        joined_attrib = '.'.join(list_of_attrib)
                        if len(list_of_attrib) > 0:
                            for w in self.List_of_both_names_asname:
                                if w[0] != None and w[0] == list_of_attrib[0]:
                                    self.flag_for_having_automl_parent = True
                                    break
                                elif w[1] != None and w[1] == list_of_attrib[0]:
                                    self.flag_for_having_automl_parent = True
                                    break
                    for body_item in item.body:
                        if isinstance(body_item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                            self.check_functions(body_item)


                elif isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    self.check_functions(item)

                else:
                    self._check(item)
                self.flag_for_having_automl_parent = False
            except Exception as e:
                print('Error overral during function calls! ', e)
                self.write_on_csv(e, ast.dump(item))
                self.flag_for_having_automl_parent = False


"""#main function

In the next cell we are:

*   Checking the version of the python file (python 2 or python 3).
*   Convert the .ipynb code to .py code.
*   We go through each source code in out dataset and get their function calls.
"""

import subprocess
import os


# import exceptions
def checking_the_version_of_python(path_to_the_source_code):
    p = subprocess.Popen("python3 -m py_compile '" + path_to_the_source_code+"'", shell=True, stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)
    error_str = ''
    for line in p.stdout.readlines():
        error_str += str(line) + '\n'
    status = p.wait()
    if status == 0:
        return True
    else:
        print("Error wrong python version is:")
        return False


import json
import ast
import nbformat
from nbconvert import PythonExporter


def replace_last(source_string, replace_what, replace_with):
    head, _sep, tail = source_string.rpartition(replace_what)
    return head + replace_with + tail


def converting_jupyter_to_python(path_to_the_source_code):
    try:
        with open(path_to_the_source_code) as fh:
            nb = nbformat.reads(fh.read(), nbformat.NO_CONVERT)
        exporter = PythonExporter()
        source, meta = exporter.from_notebook_node(nb)
        with open(replace_last(path_to_the_source_code, '.ipynb', '.py'), 'w+') as fh:
            fh.writelines(source)
        source_code1 = open(replace_last(path_to_the_source_code, '.ipynb', '.py')).read()
        return source_code1
    except Exception as e:
        print("error in utf8 in converting juoyter to py function: ", e)
        return ""


def creating_py_from_ipynb_file(source_code, path):
    path_1 = str(path).split('/')[-1].replace('.ipynb', '.py')
    path_ = path.replace(str(path).split('/')[-1], path_1)
    with open(path_, 'w') as f:
        f.write(source_code)
        f.flush()
    return path_


def write_unsuccessful_converts_to_py(fileshaa, file_path, error_messsage):

    unsuccessful_converts_to_py_writter.writerow([fileshaa, file_path, error_messsage])


def convert_python2_to_python3(file_path):
    current_path = os.path.dirname(os.path.abspath('__file__'))
    name_of_the_file = file_path.split("/")[-1]
    file_path_without_filename = file_path.replace(name_of_the_file, "")
    os.chdir(file_path_without_filename)
    p = subprocess.Popen("2to3 '" + name_of_the_file + "' -w -n", shell=True, stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)
    error_str = ''
    for line in p.stdout.readlines():
        error_str += str(line) + '\n'
    status = p.wait()
    if status == 0:
        os.chdir(current_path)
        return True
    else:
        print("error during the conversion of py2 to py3")
        os.chdir(current_path)


        return False


def check_for_syntax_error(source_code, path):

    try:
        ast.parse(source_code)
        return source_code
    except:
        new_source_code_without_syntax_error = ''
        for line in source_code.split('\n'):
            if (line.strip().startswith('!')) or (line.strip().startswith('@')) or (line.strip().startswith('%')) or (
                    line.strip().startswith('$')) or 'install' in line.strip() or 'pip ' in str(line) or 'conda ' in str(line):

                continue
            else:
                new_source_code_without_syntax_error += line + '\n'
        with open(path, 'w') as f:
            f.write(new_source_code_without_syntax_error)
            f.flush()
        return new_source_code_without_syntax_error


import os

path_to_the_main_downloaded_data_folder = path_source_code
list_of_folders = [folder for folder in os.listdir(path_to_the_main_downloaded_data_folder)]
unsuccessful_converts_to_py_file= open(path_to_the_unsuccessful_converts_to_py + 'unsuccessful_converts_to_py.csv', mode='w', newline='',encoding='utf-8')
unsuccessful_converts_to_py_writter= csv.writer(unsuccessful_converts_to_py_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
unsuccessful_converts_to_py_writter.writerow(['fileSha','file_path', ' Error'])

counter = 0
for seperate_folder in list_of_folders:
    print("###########################################################################")
    counter += 1
    print(counter)
    list_of_path = []
    print(seperate_folder)
    for (rootdir_names, dir_names, file_names) in os.walk(
            path_to_the_main_downloaded_data_folder + '/' + seperate_folder):
        for file_name in file_names:
            file_path = os.path.join(rootdir_names, file_name)
            file_sha = seperate_folder
            if file_name.endswith('.ipynb'):
                try:
                    python_version = 3
                    source_code = converting_jupyter_to_python(os.path.join(rootdir_names, file_name))
                    path_to_the_converted_to_py_file = creating_py_from_ipynb_file(source_code, file_path)
                    if not path_to_the_converted_to_py_file in list_of_path:
                        if checking_the_version_of_python(path_to_the_converted_to_py_file):
                            python_version = 3
                            source_code = check_for_syntax_error(source_code, path_to_the_converted_to_py_file)
                            list2_of_automl_related_imports = getting_the_imports(file_sha,
                                                                                  path_to_the_converted_to_py_file,
                                                                                  file_name, source_code)
                            list2_of_final_imports_or_asnames = transferring_data_from_import_function_to_function_call_function(
                                list2_of_automl_related_imports)

                            Analyze_Function_call_obj = Analyze_Function_call(list2_of_automl_related_imports,
                                                                              list2_of_final_imports_or_asnames, file_name,
                                                                              file_path, file_sha, source_code,
                                                                              path_to_error_csv, python_version)
                            Analyze_Function_call_obj.main_function()
                            Analyze_Function_call_obj.save_to_csv()
                        else:
                            python_version = 2
                            source_code = open(path_to_the_converted_to_py_file).read()
                            source_code = check_for_syntax_error(source_code, path_to_the_converted_to_py_file)
                            if convert_python2_to_python3(path_to_the_converted_to_py_file):
                                list2_of_automl_related_imports = getting_the_imports(file_sha,
                                                                                      path_to_the_converted_to_py_file,
                                                                                      file_name, source_code)
                                list2_of_final_imports_or_asnames = transferring_data_from_import_function_to_function_call_function(
                                    list2_of_automl_related_imports)

                                Analyze_Function_call_obj = Analyze_Function_call(list2_of_automl_related_imports,
                                                                                  list2_of_final_imports_or_asnames,
                                                                                  file_name,
                                                                                  file_path, file_sha, source_code,
                                                                                  path_to_error_csv, python_version)
                                Analyze_Function_call_obj.main_function()
                                Analyze_Function_call_obj.save_to_csv()
                            else:
                                print('  --- Could not convert Jupyter to python3 for: ', file_path)
                                unsuccessful_converts_to_py_writter.writerow([seperate_folder, file_path, 'Error could not converted Jupyter code to python3'])
                        list_of_path.append(path_to_the_converted_to_py_file)
                except Exception as e:
                    print('Exception in jupyter...')
            if file_name.endswith('.py'):
                if not file_path in list_of_path:
                    try:
                        if checking_the_version_of_python(os.path.join(rootdir_names, file_name)):
                            python_version = 3
                            source_code = open(os.path.join(rootdir_names, file_name)).read()
                            source_code = check_for_syntax_error(source_code, file_path)
                            list2_of_automl_related_imports = getting_the_imports(file_sha, file_path, file_name,
                                                                                  source_code)
                            list2_of_final_imports_or_asnames = transferring_data_from_import_function_to_function_call_function(
                                list2_of_automl_related_imports)

                            Analyze_Function_call_obj = Analyze_Function_call(list2_of_automl_related_imports,
                                                                              list2_of_final_imports_or_asnames,
                                                                              file_name,
                                                                              file_path, file_sha, source_code,
                                                                              path_to_error_csv, python_version)
                            Analyze_Function_call_obj.main_function()
                            Analyze_Function_call_obj.save_to_csv()

                        else:
                            source_code = open(os.path.join(rootdir_names, file_name)).read()
                            source_code = check_for_syntax_error(source_code, file_path)
                            if convert_python2_to_python3(file_path):
                                python_version = 2
                                list2_of_automl_related_imports = getting_the_imports(file_sha, file_path, file_name,
                                                                                      source_code)
                                list2_of_final_imports_or_asnames = transferring_data_from_import_function_to_function_call_function(
                                    list2_of_automl_related_imports)

                                Analyze_Function_call_obj = Analyze_Function_call(list2_of_automl_related_imports,
                                                                                  list2_of_final_imports_or_asnames,
                                                                                  file_name,
                                                                                  file_path, file_sha, source_code,
                                                                                  path_to_error_csv, python_version)
                                Analyze_Function_call_obj.main_function()
                                Analyze_Function_call_obj.save_to_csv()
                            else:
                                print('  --- Could not convert to python3 for: ', file_path)
                                unsuccessful_converts_to_py_writter.writerow(
                                    [seperate_folder, file_path, 'Could not convert python2 to python3'])
                    except Exception as e:
                        print("error related to utf-8", e)
                        unsuccessful_converts_to_py_writter.writerow(
                            [seperate_folder, file_path, 'error related to file fomart utf-8: '+str(e)])
                    list_of_path.append(file_path)
unsuccessful_converts_to_py_file.close()




